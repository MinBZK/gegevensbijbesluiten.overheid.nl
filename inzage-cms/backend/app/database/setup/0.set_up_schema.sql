-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS bestand_acc
(
    bestand_acc_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    volg_nr integer NOT NULL,
    omschrijving character varying(255) COLLATE pg_catalog."default",
    bestand_verwijzing character varying(255) COLLATE pg_catalog."default" NOT NULL,
    ts_create timestamp without time zone NOT NULL,
    CONSTRAINT bestand_acc_pk PRIMARY KEY (bestand_acc_cd)
);

COMMENT ON TABLE bestand_acc
    IS 'De bestanden die horen ter bewijslast voor de accorderingen';

COMMENT ON COLUMN bestand_acc.bestand_acc_cd
    IS 'Uniek ID';

COMMENT ON COLUMN bestand_acc.volg_nr
    IS 'Volgnummer';

COMMENT ON COLUMN bestand_acc.omschrijving
    IS 'Bestand omschrijving';

COMMENT ON COLUMN bestand_acc.bestand_verwijzing
    IS 'Betandsverwijzing';

COMMENT ON COLUMN bestand_acc.ts_create
    IS 'Tijdstip accordering';

CREATE TABLE IF NOT EXISTS evtp
(
    evtp_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    evtp_upc character varying(8) NOT NULL,
    evtp_nm character varying(200) COLLATE pg_catalog."default" NOT NULL,
    omschrijving character varying(2000) COLLATE pg_catalog."default",
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    evtp_cd_sup integer,
    ts_mut timestamp without time zone NOT NULL,
    srt_event character varying(12) COLLATE pg_catalog."default",
    oe_best integer NOT NULL,
    aanleiding character varying(2000) COLLATE pg_catalog."default" NOT NULL,
    gebr_dl character varying(200) COLLATE pg_catalog."default" NOT NULL,
    ind_pilot character(1) COLLATE pg_catalog."default" DEFAULT 'N'::bpchar,
    sort_key integer,
    gg_cd integer,
    lidw_soort_besluit character varying(12) COLLATE pg_catalog."default",
    soort_besluit character varying(50) COLLATE pg_catalog."default",
    id_publicatiestatus integer NOT NULL,
    CONSTRAINT evtp_pk PRIMARY KEY (evtp_cd),
    CONSTRAINT evtp_cd_unique UNIQUE (evtp_cd)
);

COMMENT ON TABLE evtp
    IS 'Relevante soorten gebeurtenissen die aanleiding (kunnen) zijn voor het vastleggen of uitwisselen van gegevens(groepen)';

COMMENT ON COLUMN evtp.evtp_cd
    IS 'Eventtype code';

COMMENT ON COLUMN evtp.evtp_upc
    IS 'Unieke UPC code voor een ieder besluit';

COMMENT ON COLUMN evtp.evtp_nm
    IS 'Naam van het event type';

COMMENT ON COLUMN evtp.omschrijving
    IS 'Omschrijving van het Eventtype';

COMMENT ON COLUMN evtp.user_nm
    IS 'User identification.';

COMMENT ON COLUMN evtp.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN evtp.evtp_cd_sup
    IS 'Hogere eventtype';

COMMENT ON COLUMN evtp.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN evtp.srt_event
    IS 'Soort event';

COMMENT ON COLUMN evtp.oe_best
    IS 'Voor het event verantwoordelijke organisatie';

COMMENT ON COLUMN evtp.aanleiding
    IS 'Aanleiding of context waarin besluit genomen wordt';

COMMENT ON COLUMN evtp.gebr_dl
    IS 'Aanleiding of context waarin besluit genomen wordt';

COMMENT ON COLUMN evtp.ind_pilot
    IS 'Zit deze in de pilot?';

COMMENT ON COLUMN evtp.sort_key
    IS 'Sorteersleutel';

CREATE TABLE IF NOT EXISTS evtp_acc
(
    evtp_acc_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    evtp_cd integer NOT NULL,
    oe_cd integer NOT NULL,
    ts_acc timestamp without time zone NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    volg_nr integer NOT NULL,
    bestand_acc_cd integer,
    CONSTRAINT idx_17917_primary PRIMARY KEY (evtp_acc_cd)
);

COMMENT ON TABLE evtp_acc
    IS 'Accorderingen die gegeven worden door een organisatie op een besluit';

COMMENT ON COLUMN evtp_acc.evtp_acc_cd
    IS 'Uniek accorderings ID';

COMMENT ON COLUMN evtp_acc.evtp_cd
    IS 'Eventtype code';

COMMENT ON COLUMN evtp_acc.oe_cd
    IS 'Organisatorische eenheid code';

COMMENT ON COLUMN evtp_acc.ts_acc
    IS 'Tijdstip accordering';

COMMENT ON COLUMN evtp_acc.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN evtp_acc.volg_nr
    IS 'Volgnummer';

COMMENT ON COLUMN evtp_acc.bestand_acc_cd
    IS 'Bestandtype code';

CREATE TABLE IF NOT EXISTS evtp_gst
(
    evtp_gst_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    evtp_cd integer NOT NULL,
    gst_cd integer NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    conditie character varying(4000) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    sort_key integer,
    CONSTRAINT evtp_gst_pk PRIMARY KEY (evtp_gst_cd),
    CONSTRAINT evtp_gst_unique UNIQUE (evtp_gst_cd)
);

COMMENT ON TABLE evtp_gst
    IS 'Cross-reference tusen gegevensstroom en eventtypen';

COMMENT ON COLUMN evtp_gst.evtp_cd
    IS 'Soort gebeurtenis van een gegevensstroom';

COMMENT ON COLUMN evtp_gst.gst_cd
    IS 'Gegevensstroom nav een soort gebeurtenis';

COMMENT ON COLUMN evtp_gst.notitie
    IS 'Notitie';

COMMENT ON COLUMN evtp_gst.conditie
    IS 'Toelichting van een conditie waaronder de gegevensstroom plaatsvindt, bijvoorbeeld ziek worden, wel of geen werk hebben, etc ';

COMMENT ON COLUMN evtp_gst.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN evtp_gst.sort_key
    IS 'Sorteersleutel';

CREATE TABLE IF NOT EXISTS gg
(
    gg_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    omschrijving character varying(4000) COLLATE pg_catalog."default" NOT NULL,
    sys_nm character varying(15) COLLATE pg_catalog."default",
    rt_nm character varying(30) COLLATE pg_catalog."default",
    col_nm character varying(30) COLLATE pg_catalog."default",
    dom_nm character varying(18) COLLATE pg_catalog."default",
    ibron_cd integer,
    omschrijving_uitgebreid character varying(4000) NOT NULL,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    ts_mut timestamp without time zone NOT NULL,
    notitie character varying(2000) COLLATE pg_catalog."default",
    ind_pilot character(1) COLLATE pg_catalog."default",
    sort_key integer,
    CONSTRAINT gg_pk PRIMARY KEY (gg_cd)
);

COMMENT ON TABLE gg
    IS 'Groepen of elementaire soorten gegevens';

COMMENT ON COLUMN gg.gg_cd
    IS 'Gegevensgroep code';

COMMENT ON COLUMN gg.omschrijving
    IS 'Omschrijving/Naam van de gegevensgroep';

COMMENT ON COLUMN gg.sys_nm
    IS 'System name';

COMMENT ON COLUMN gg.rt_nm
    IS 'Table or view name.';

COMMENT ON COLUMN gg.col_nm
    IS 'Column name';

COMMENT ON COLUMN gg.dom_nm
    IS 'Domain name';

COMMENT ON COLUMN gg.ibron_cd
    IS 'Code bron van wie de gegevens in het dataWHEREhouse afkomstig zijn.';

COMMENT ON COLUMN gg.omschrijving_uitgebreid
    IS 'Uitleg uitgebreid van gegevensgroep';

COMMENT ON COLUMN gg.user_nm
    IS 'User identification.';

COMMENT ON COLUMN gg.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN gg.notitie
    IS 'Kort toelichting ter duiding van een gegevensgroep';

COMMENT ON COLUMN gg.ind_pilot
    IS 'Status publicatie';

CREATE TABLE IF NOT EXISTS gst
(
    gst_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    gst_upc character varying(8) NOT NULL,
    omschrijving character varying(255) COLLATE pg_catalog."default" NOT NULL,
    oe_bron integer NOT NULL,
    oe_best integer NOT NULL,
    ibron_cd integer,
    notitie character varying(4000) COLLATE pg_catalog."default",
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    ts_mut timestamp without time zone NOT NULL,
    ext_lnk_aut character varying(2000) COLLATE pg_catalog."default",
    ind_pilot character(1) COLLATE pg_catalog."default" DEFAULT 'N'::bpchar,
    CONSTRAINT gst_pk PRIMARY KEY (gst_cd),
    CONSTRAINT gst_cd_unique UNIQUE (gst_cd)
);

COMMENT ON TABLE gst
    IS 'Gegevensstromen tussen (soorten) organisatorische eenheden/instanties';

COMMENT ON COLUMN gst.gst_cd
    IS 'Gegevensstroom code';

COMMENT ON COLUMN gst.gst_upc
    IS 'Unieke UPC code voor een ieder gegevensstroom';

COMMENT ON COLUMN gst.omschrijving
    IS 'Omschrijving/Naam gegevensstroom';

COMMENT ON COLUMN gst.oe_bron
    IS 'Afkomstig van organisatorische eenheid';

COMMENT ON COLUMN gst.oe_best
    IS 'Afnemer (= organ. eenheid)';

COMMENT ON COLUMN gst.ibron_cd
    IS 'Code bron van wie de gegevens in het dataWHEREhouse afkomstig zijn.';

COMMENT ON COLUMN gst.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN gst.user_nm
    IS 'User identification.';

COMMENT ON COLUMN gst.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN gst.ext_lnk_aut
    IS 'Hyperlink naar autorisatie';

COMMENT ON COLUMN gst.ind_pilot
    IS 'Zit deze in de pilot?';

CREATE TABLE IF NOT EXISTS gg_struct
(
    gg_struct_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    gg_cd_sub integer NOT NULL,
    gg_cd_sup integer NOT NULL,
    ind_verplicht character(1) COLLATE pg_catalog."default",
    ind_identificerend character(1) COLLATE pg_catalog."default",
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    CONSTRAINT gg_struct_pk PRIMARY KEY (gg_struct_cd),
    CONSTRAINT ggs_struct_unique UNIQUE (gg_struct_cd)
);

COMMENT ON TABLE gg_struct
    IS 'Relatie tussen gegevensgroepen van een bepaalse soort';

COMMENT ON COLUMN gg_struct.gg_cd_sub
    IS 'Gegevensgroep lager';

COMMENT ON COLUMN gg_struct.gg_cd_sup
    IS 'Gegevensgroep hoger';

COMMENT ON COLUMN gg_struct.ind_verplicht
    IS 'Is voorkomen van lagere gegevensgroep verplicht in hogere groep?';

COMMENT ON COLUMN gg_struct.ind_identificerend
    IS 'Is lagere gegevensgroep identificerend voor hogere groep?';

COMMENT ON COLUMN gg_struct.user_nm
    IS 'User identification.';

COMMENT ON COLUMN gg_struct.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN gg_struct.ts_mut
    IS 'Tijdstip laatste mutatie';

CREATE TABLE IF NOT EXISTS gst_gg_rge
(
    gst_gg_rge_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    gst_cd integer NOT NULL,
    rge_cd integer NOT NULL,
    gg_cd integer NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    ibron_cd integer,
    ind_expl character varying(6) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    CONSTRAINT gst_gg_rge_pk PRIMARY KEY (gst_gg_rge_cd),
    CONSTRAINT gst_gg_rge_unique UNIQUE (gst_gg_rge_cd)
);

COMMENT ON TABLE gst_gg_rge
    IS 'Relatie tussen gegevensstroom, gegevensgroep en wettelijke grondslag';

COMMENT ON COLUMN gst_gg_rge.gst_cd
    IS 'Code van de gegevensstroom waarmee gekoppeld wordt';

COMMENT ON COLUMN gst_gg_rge.rge_cd
    IS 'Code van de wettelijke grondslag waarmee gekoppeld wordt';

COMMENT ON COLUMN gst_gg_rge.gg_cd
    IS 'Code van gegevensgroep waarmee gekoppeld wordt';

COMMENT ON COLUMN gst_gg_rge.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN gst_gg_rge.ibron_cd
    IS 'Bron waarvan informatie afkomstig is';

COMMENT ON COLUMN gst_gg_rge.ind_expl
    IS 'indicator die aangeeft of wettelijke grondslag impliciet of expliciet aanwezig is';

COMMENT ON COLUMN gst_gg_rge.ts_mut
    IS 'Tijdstip laatste mutatie';

CREATE TABLE IF NOT EXISTS gst_gstt
(
    gst_gstt_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    gst_cd integer NOT NULL,
    gstt_cd integer NOT NULL,
    CONSTRAINT gst_gstt_pk PRIMARY KEY (gst_gstt_cd)
);

COMMENT ON TABLE gst_gstt
    IS 'Relatie tussen gegevensstroom en gegevensstroomtype';

COMMENT ON COLUMN gst_gstt.gst_cd
    IS 'Code gegevensstroom';

COMMENT ON COLUMN gst_gstt.gstt_cd
    IS 'Code soort gegevensstroom';

CREATE TABLE IF NOT EXISTS gst_type
(
    gstt_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    gstt_naam character varying(200) COLLATE pg_catalog."default" NOT NULL,
    gstt_oms character varying(2000) COLLATE pg_catalog."default" NOT NULL,
    ts_mut timestamp without time zone NOT NULL,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    gstt_pp character varying(20) COLLATE pg_catalog."default",
    sort_key integer,
    CONSTRAINT gstt_pk PRIMARY KEY (gstt_cd),
    CONSTRAINT gstt_cd_unique UNIQUE (gstt_cd)
);

COMMENT ON TABLE gst_type
    IS 'Type gegevensstroom';

COMMENT ON COLUMN gst_type.gstt_cd
    IS 'Code soort gegevensstroom';

COMMENT ON COLUMN gst_type.gstt_naam
    IS 'Naam van het soort stroom';

COMMENT ON COLUMN gst_type.gstt_oms
    IS 'Kort omschrijving van de gegevensstroom';

COMMENT ON COLUMN gst_type.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN gst_type.user_nm
    IS 'Id gebruiker';

COMMENT ON COLUMN gst_type.gstt_pp
    IS 'Push of pull van een gegevenstroom type';

CREATE TABLE IF NOT EXISTS ibron
(
    ibron_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    omschrijving character varying(80) COLLATE pg_catalog."default" NOT NULL,
    oe_cd integer,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    CONSTRAINT ibron_pk PRIMARY KEY (ibron_cd),
    CONSTRAINT ibrn_unique UNIQUE (ibron_cd)
);

COMMENT ON TABLE ibron
    IS 'Registratie waar de gegevens afkomstig van zijn.';

COMMENT ON COLUMN ibron.ibron_cd
    IS 'Code bron van wie de gegevens in het dataWHEREhouse afkomstig zijn.';

COMMENT ON COLUMN ibron.omschrijving
    IS 'Omschrijving/naam van de bron';

COMMENT ON COLUMN ibron.oe_cd
    IS 'Organisatorische eenheid code';

COMMENT ON COLUMN ibron.user_nm
    IS 'User identification.';

COMMENT ON COLUMN ibron.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN ibron.ts_mut
    IS 'Tijdstip laatste mutatie';

CREATE TABLE IF NOT EXISTS oe_struct
(
    oe_struct_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    oe_cd_sup integer NOT NULL,
    oe_cd_sub integer NOT NULL,
    osrt_cd integer NOT NULL,
    ibron_cd integer,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    CONSTRAINT oe_struct_pk PRIMARY KEY (oe_struct_cd),
    CONSTRAINT oe_struct_unique UNIQUE (oe_struct_cd)
);

COMMENT ON TABLE oe_struct
    IS 'Relatie van een bepaald type tussen twee organisatorische eenheden/instanties';

COMMENT ON COLUMN oe_struct.oe_cd_sup
    IS 'Hogere organisatorische eenheid';

COMMENT ON COLUMN oe_struct.oe_cd_sub
    IS 'Lagere organisatorische eenheid';

COMMENT ON COLUMN oe_struct.osrt_cd
    IS 'Rol(type) organisatorische eenheid';

COMMENT ON COLUMN oe_struct.ibron_cd
    IS 'Code bron van wie de gegevens in het dataWHEREhouse afkomstig zijn.';

COMMENT ON COLUMN oe_struct.user_nm
    IS 'User identification.';

COMMENT ON COLUMN oe_struct.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN oe_struct.ts_mut
    IS 'Tijdstip laatste mutatie';

CREATE TABLE IF NOT EXISTS oe_struct_rolt
(
    osrt_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    omschrijving character varying(80) COLLATE pg_catalog."default" NOT NULL,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    CONSTRAINT osrt_pk PRIMARY KEY (osrt_cd),
    CONSTRAINT osrt_unique UNIQUE (osrt_cd)
);

COMMENT ON TABLE oe_struct_rolt
    IS 'Soort relatie die organisatorische eenheden/instanties met elkaar kunnen hebben';

COMMENT ON COLUMN oe_struct_rolt.osrt_cd
    IS 'Roltype code van organisatiestructuur ( '' valt bestuurlijk onder.., etc.)';

COMMENT ON COLUMN oe_struct_rolt.omschrijving
    IS 'Omschrijving van het roltype';

COMMENT ON COLUMN oe_struct_rolt.user_nm
    IS 'User identification.';

COMMENT ON COLUMN oe_struct_rolt.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN oe_struct_rolt.ts_mut
    IS 'Tijdstip laatste mutatie';

CREATE TABLE IF NOT EXISTS oe_type
(
    oe_type_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    omschrijving character varying(80) COLLATE pg_catalog."default" NOT NULL,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    get_label character varying(14) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    icout_id integer,
    CONSTRAINT oe_type_pk PRIMARY KEY (oe_type_cd),
    CONSTRAINT oet_unique UNIQUE (oe_type_cd)
);

COMMENT ON TABLE oe_type
    IS 'Type organisatorische eenheid';

COMMENT ON COLUMN oe_type.oe_type_cd
    IS 'Soort organisatorische eenheid of entiteit';

COMMENT ON COLUMN oe_type.omschrijving
    IS 'Omschrijving organisatorische eenheid of entiteit';

COMMENT ON COLUMN oe_type.user_nm
    IS 'User identification.';

COMMENT ON COLUMN oe_type.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN oe_type.get_label
    IS 'Label voor grafische weergave';

COMMENT ON COLUMN oe_type.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN oe_type.icout_id
    IS 'Nummer uit BSN-Landkaart';

CREATE TABLE IF NOT EXISTS oe
(
    oe_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    naam_spraakgbr character varying(255) COLLATE pg_catalog."default" NOT NULL,
    naam_officieel character varying(4000) COLLATE pg_catalog."default" NOT NULL,
    afko character varying(15) COLLATE pg_catalog."default",
    oe_type_cd integer NOT NULL,
    straat character varying(30) COLLATE pg_catalog."default",
    huisnummer character varying(10) COLLATE pg_catalog."default",
    huisnummer_toev character varying(10) COLLATE pg_catalog."default",
    postcode character varying(7) COLLATE pg_catalog."default",
    telefoon character varying(30) COLLATE pg_catalog."default",
    fax bigint,
    internet_domein character varying(200) COLLATE pg_catalog."default",
    e_contact character varying(200) COLLATE pg_catalog."default",
    ibron_cd integer,
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    plaats character varying(30) COLLATE pg_catalog."default",
    provincie character varying(30) COLLATE pg_catalog."default",
    id_ext_bron character varying(12) COLLATE pg_catalog."default",
    ind_brf character(1) COLLATE pg_catalog."default",
    srt_brf character(1) COLLATE pg_catalog."default",
    ind_gebr character(1) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    lidw_sgebr character varying(12) COLLATE pg_catalog."default" NOT NULL,
    ind_pilot character(1) COLLATE pg_catalog."default" DEFAULT 'N'::bpchar,
    rge_cd integer,
    e_contact_omschrijving character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT oe_pk PRIMARY KEY (oe_cd),
    CONSTRAINT oe_unique UNIQUE (oe_cd)
);

COMMENT ON TABLE oe
    IS 'Organisatorische eenheid/instantie of soort van organisatorische entiteit';

COMMENT ON COLUMN oe.oe_cd
    IS 'Organisatorische eenheid code';

COMMENT ON COLUMN oe.naam_spraakgbr
    IS 'Naam die gebruikt voor in het ''normale''  spraakgebruik';

COMMENT ON COLUMN oe.naam_officieel
    IS 'Taken van de organistorische eenheid';

COMMENT ON COLUMN oe.afko
    IS 'Afkorting van de organisatorische eenheid';

COMMENT ON COLUMN oe.oe_type_cd
    IS 'Soort organisatorische eenheid of entiteit';

COMMENT ON COLUMN oe.straat
    IS 'Straatnaam cf. postcode tabel of ''Postbus''';

COMMENT ON COLUMN oe.huisnummer
    IS 'Huisnummer cf. postcode tabel';

COMMENT ON COLUMN oe.huisnummer_toev
    IS 'Huisnummer toevoeging';

COMMENT ON COLUMN oe.postcode
    IS 'Nederlandse postcode';

COMMENT ON COLUMN oe.telefoon
    IS 'Telefoonnummer (volledig)';

COMMENT ON COLUMN oe.fax
    IS 'Faxnummer (volledig)';

COMMENT ON COLUMN oe.internet_domein
    IS 'Internet domeinnaam';

COMMENT ON COLUMN oe.e_contact
    IS 'E-mail contactadres - indien alleen een prefix is opgenomen wordt de domeinnaam ge-append';

COMMENT ON COLUMN oe.ibron_cd
    IS 'Code bron van wie de gegevens in het dataWHEREhouse afkomstig zijn.';

COMMENT ON COLUMN oe.user_nm
    IS 'User identification.';

COMMENT ON COLUMN oe.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN oe.plaats
    IS '(Woon)plaats';

COMMENT ON COLUMN oe.provincie
    IS 'Provincie';

COMMENT ON COLUMN oe.id_ext_bron
    IS 'De code of het id die gebruikt wordt bij de externe bron waar de content van afkomstig is';

COMMENT ON COLUMN oe.ind_brf
    IS 'Of vanuit ICTU een brief met verzoek aanlevering wordt gestuurd.';

COMMENT ON COLUMN oe.srt_brf
    IS 'Soort brief wat verstuurd wordt';

COMMENT ON COLUMN oe.ind_gebr
    IS 'Soort gebruikers (ja is overheidsorgaan, nee is overige gebruiker)';

COMMENT ON COLUMN oe.ts_mut
    IS 'Tijdstip laatste mutatie';

COMMENT ON COLUMN oe.lidw_sgebr
    IS 'Lidwoord van de organisatie (de, het, een)';

COMMENT ON COLUMN oe.ind_pilot
    IS 'Zit deze in de pilot?';

COMMENT ON COLUMN oe.rge_cd
    IS 'Regelgeving die ten grondslag ligt aan de organisatie';

COMMENT ON COLUMN oe.e_contact_omschrijving
    IS 'Omschrijving van de persoonlijke toegang tot gegevens bij deze organisatie';

CREATE TABLE IF NOT EXISTS rge
(
    rge_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    titel character varying(255) COLLATE pg_catalog."default" NOT NULL,
    tekst character varying(4000) COLLATE pg_catalog."default",
    user_nm character varying(30) COLLATE pg_catalog."default" NOT NULL,
    notitie character varying(4000) COLLATE pg_catalog."default",
    re_type character varying(5) COLLATE pg_catalog."default",
    re_link character varying(300) COLLATE pg_catalog."default",
    ts_mut timestamp without time zone NOT NULL,
    CONSTRAINT rge_unique PRIMARY KEY (rge_cd),
    CONSTRAINT reg_unique UNIQUE (rge_cd)
);

COMMENT ON TABLE rge
    IS '(Onderdeel van) wet- en regelgeving - kunnen wetten zijn maar ook wetsartikelen of uitvoeringsregelingen';

COMMENT ON COLUMN rge.rge_cd
    IS 'Regeling id.';

COMMENT ON COLUMN rge.titel
    IS 'Naam/omschrijving/titel van een regelingelement';

COMMENT ON COLUMN rge.tekst
    IS 'Officiele tekst';

COMMENT ON COLUMN rge.user_nm
    IS 'User identification.';

COMMENT ON COLUMN rge.notitie
    IS 'Notitieveld';

COMMENT ON COLUMN rge.re_type
    IS 'Aanduiding van het soort wet of regelgeving het betreft ( wet in formele zin, materiele zin, etc)';

COMMENT ON COLUMN rge.re_link
    IS '(Deep) link naar wet of regelgeving';

COMMENT ON COLUMN rge.ts_mut
    IS 'Tijdstip laatste mutatie';

CREATE TABLE IF NOT EXISTS rubriekenvoorbeheer
(
    rubrieken_cd integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    rubrieknaam character varying(255) COLLATE pg_catalog."default" NOT NULL,
    tabelnaam character varying(255) COLLATE pg_catalog."default" NOT NULL,
    rubriekcomment character varying(200) COLLATE pg_catalog."default",
    rubrieklabelkort character varying(60) COLLATE pg_catalog."default",
    rubrieklabellang character varying(255) COLLATE pg_catalog."default",
    indrubriekinbeheer integer NOT NULL DEFAULT 1,
    rubriekdefaultwaarde character varying(200) COLLATE pg_catalog."default",
    rubriekismagleegzijn character varying(1) COLLATE pg_catalog."default" NOT NULL,
    rubriekdataformat character varying(45) COLLATE pg_catalog."default",
    rubriekissleutel character varying(1) COLLATE pg_catalog."default",
    rubriekvolgordenummer integer,
    rubriekmutatietype character varying(1) COLLATE pg_catalog."default",
    rubriekmutatietypeomschrijving character varying(2000) COLLATE pg_catalog."default",
    rubriekreferentie character varying(200) COLLATE pg_catalog."default",
    notitie character varying(4000) COLLATE pg_catalog."default",
    CONSTRAINT rubrieken_pk PRIMARY KEY (rubrieken_cd)
);

COMMENT ON TABLE rubriekenvoorbeheer
    IS 'Rubrieken in inzage die beheerd kunnen worden';

COMMENT ON COLUMN rubriekenvoorbeheer.rubrieknaam
    IS 'Naam van de rubriek in de database';

COMMENT ON COLUMN rubriekenvoorbeheer.tabelnaam
    IS 'Naam van de tabel in de database';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekcomment
    IS 'Rubriek comment in de database';

COMMENT ON COLUMN rubriekenvoorbeheer.rubrieklabelkort
    IS 'Rubriek label (kort) voor op het scherm';

COMMENT ON COLUMN rubriekenvoorbeheer.rubrieklabellang
    IS 'Rubriek label (lang) voor op het scherm';

COMMENT ON COLUMN rubriekenvoorbeheer.indrubriekinbeheer
    IS 'Indicator of desbetreffende rubriek opgenomen moet worden in het beheerscherm';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekdefaultwaarde
    IS 'Standaard waarde van de rubriek';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekismagleegzijn
    IS 'Indicator of de rubriek leeg (null) gelaten mag worden';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekdataformat
    IS 'Het data formaat van de rubriek in de database';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekissleutel
    IS 'Indicator of de rubriek onderdeel uitmaakt van een sleutel';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekvolgordenummer
    IS 'Volgorde van de rubriek voor het tonen op het beheerscherm';

COMMENT ON COLUMN rubriekenvoorbeheer.rubriekreferentie
    IS 'Tabel en kolom waarnaar deze rubriek verwijst middels een foreign key';

CREATE TABLE IF NOT EXISTS tabellenvoorbeheer
(
    tabelnaam character varying(255) COLLATE pg_catalog."default" NOT NULL,
    tabelcomment character varying(200) COLLATE pg_catalog."default",
    tabellabelkort character varying(60) COLLATE pg_catalog."default",
    tabellabellang character varying(255) COLLATE pg_catalog."default",
    indtabelinbeheer integer NOT NULL DEFAULT 1,
    notitie character varying(4000) COLLATE pg_catalog."default",
    CONSTRAINT tabelnaam_pk PRIMARY KEY (tabelnaam),
    CONSTRAINT "Tabelnaam_UNIQUE" UNIQUE (tabelnaam)
);

COMMENT ON TABLE tabellenvoorbeheer
    IS 'Tabellen in inzage die beheerd kunnen worden';

ALTER TABLE IF EXISTS evtp
    ADD CONSTRAINT evt_evt_fk FOREIGN KEY (evtp_cd_sup)
    REFERENCES evtp (evtp_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17910_evt_evt_fk
    ON evtp(evtp_cd_sup);
CREATE INDEX IF NOT EXISTS idx_18001_evt_evt_upc_fk
    ON evtp(evtp_upc);


ALTER TABLE IF EXISTS evtp
    ADD CONSTRAINT evt_gg_fk FOREIGN KEY (gg_cd)
    REFERENCES gg (gg_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17910_evt_gg_fk_idx
    ON evtp(gg_cd);


ALTER TABLE IF EXISTS evtp
    ADD CONSTRAINT evt_oe_fk FOREIGN KEY (oe_best)
    REFERENCES oe (oe_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17910_evt_oe_fk
    ON evtp(oe_best);


ALTER TABLE IF EXISTS evtp_acc
    ADD CONSTRAINT evtp_acc_bestand_fk FOREIGN KEY (bestand_acc_cd)
    REFERENCES bestand_acc (bestand_acc_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17917_evtp_acc_bestand_fk
    ON evtp_acc(bestand_acc_cd);


ALTER TABLE IF EXISTS evtp_acc
    ADD CONSTRAINT evtp_acc_cd_fk FOREIGN KEY (evtp_cd)
    REFERENCES evtp (evtp_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17917_evtp_acc_cd_fk
    ON evtp_acc(evtp_cd);


ALTER TABLE IF EXISTS evtp_acc
    ADD CONSTRAINT evtp_acc_oe_fk FOREIGN KEY (oe_cd)
    REFERENCES oe (oe_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17917_evtp_acc_oe_fk
    ON evtp_acc(oe_cd);


ALTER TABLE IF EXISTS evtp_gst
    ADD CONSTRAINT evtpgst_evtp_fk FOREIGN KEY (evtp_cd)
    REFERENCES evtp (evtp_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17917_evtp_gst_evtp_fk
    ON evtp_gst(evtp_cd);
CREATE INDEX IF NOT EXISTS idx_17917_evtp_gst_gst_fk
    ON evtp_gst(gst_cd);


ALTER TABLE IF EXISTS evtp_gst
    ADD CONSTRAINT evtpgst_gst_fk FOREIGN KEY (gst_cd)
    REFERENCES gst (gst_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS gg
    ADD CONSTRAINT gg_ibrn_fk FOREIGN KEY (ibron_cd)
    REFERENCES ibron (ibron_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17935_gg_ibrn_fk
    ON gg(ibron_cd);


ALTER TABLE IF EXISTS gst
    ADD CONSTRAINT gst_ibrn_fk FOREIGN KEY (ibron_cd)
    REFERENCES ibron (ibron_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17941_gst_ibrn_fk
    ON gst(ibron_cd);
CREATE INDEX IF NOT EXISTS idx_18002_gst_upc_fk
    ON gst(gst_upc);


ALTER TABLE IF EXISTS gst
    ADD CONSTRAINT gst_oe_best FOREIGN KEY (oe_best)
    REFERENCES oe (oe_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17941_gst_oe_best
    ON gst(oe_best);


ALTER TABLE IF EXISTS gst
    ADD CONSTRAINT gst_oe_bron FOREIGN KEY (oe_bron)
    REFERENCES oe (oe_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17941_gst_oe_bron
    ON gst(oe_bron);


ALTER TABLE IF EXISTS gg_struct
    ADD CONSTRAINT ggs_gg_sub_fk FOREIGN KEY (gg_cd_sub)
    REFERENCES gg (gg_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;
CREATE INDEX IF NOT EXISTS idx_17941_gg_sub_fk
    ON gg_struct(gg_cd_sub);
CREATE INDEX IF NOT EXISTS idx_17941_gg_sup_fk
    ON gg_struct(gg_cd_sup);


ALTER TABLE IF EXISTS gg_struct
    ADD CONSTRAINT ggs_gg_sup_fk FOREIGN KEY (gg_cd_sup)
    REFERENCES gg (gg_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS gst_gg_rge
    ADD CONSTRAINT ggr_gg_sk FOREIGN KEY (gg_cd)
    REFERENCES gg (gg_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17975_ggr_gst_fk
    ON gst_gg_rge(gst_cd);


ALTER TABLE IF EXISTS gst_gg_rge
    ADD CONSTRAINT ggr_ibron_fk FOREIGN KEY (ibron_cd)
    REFERENCES ibron (ibron_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17975_ggr_ibron_fk
    ON gst_gg_rge(ibron_cd);


ALTER TABLE IF EXISTS gst_gg_rge
    ADD CONSTRAINT ggr_rge_fk FOREIGN KEY (rge_cd)
    REFERENCES rge (rge_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17975_ggr_rge_fk
    ON gst_gg_rge(rge_cd);


ALTER TABLE IF EXISTS gst_gg_rge
    ADD CONSTRAINT ggr_gst_sk FOREIGN KEY (gst_cd)
    REFERENCES gst (gst_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;
CREATE INDEX IF NOT EXISTS idx_17975_ggr_gg_fk
    ON gst_gg_rge(gg_cd);


ALTER TABLE IF EXISTS gst_gstt
    ADD CONSTRAINT gst_gstt_gst_fk FOREIGN KEY (gst_cd)
    REFERENCES gst (gst_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_17975_gstt_gst_fk
    ON gst_gstt(gst_cd);


ALTER TABLE IF EXISTS gst_gstt
    ADD CONSTRAINT gst_gstt_gstt_fk FOREIGN KEY (gstt_cd)
    REFERENCES gst_type (gstt_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;
CREATE INDEX IF NOT EXISTS idx_17975_gstt_gstt_fk
    ON gst_gstt(gstt_cd);


CREATE INDEX IF NOT EXISTS idx_17975_ibron_oe_fk
    ON ibron(oe_cd);


ALTER TABLE IF EXISTS oe_struct
    ADD CONSTRAINT oes_ibrn_fk FOREIGN KEY (ibron_cd)
    REFERENCES ibron (ibron_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_18044_oes_ibrn_fk
    ON oe_struct(ibron_cd);


ALTER TABLE IF EXISTS oe_struct
    ADD CONSTRAINT oes_oe_sub_fk FOREIGN KEY (oe_cd_sub)
    REFERENCES oe (oe_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS oe_struct
    ADD CONSTRAINT oes_oe_sup_fk FOREIGN KEY (oe_cd_sup)
    REFERENCES oe (oe_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS oe_struct
    ADD CONSTRAINT oes_osrt_fk FOREIGN KEY (osrt_cd)
    REFERENCES oe_struct_rolt (osrt_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS oe
    ADD CONSTRAINT oe_ibrn_fk FOREIGN KEY (ibron_cd)
    REFERENCES ibron (ibron_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_18062_oe_ibrn_fk
    ON oe(ibron_cd);


ALTER TABLE IF EXISTS oe
    ADD CONSTRAINT oe_oet_fk FOREIGN KEY (oe_type_cd)
    REFERENCES oe_type (oe_type_cd) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_18062_oe_oet_fk
    ON oe(oe_type_cd);
CREATE INDEX IF NOT EXISTS idx_18062_oe_rge_fk
    ON oe(rge_cd);


ALTER TABLE IF EXISTS rubriekenvoorbeheer
    ADD CONSTRAINT "RubriekTabel_fk" FOREIGN KEY (tabelnaam)
    REFERENCES tabellenvoorbeheer (tabelnaam) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE
    NOT VALID;

END;